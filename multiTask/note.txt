除了创建、结束之外，每个进程有三种状态: 运行、就绪、阻塞

进程之间是独立的，但可以依靠特定的方法去通信。它们依靠自己的资源(计算和存储)，随时判断自己应该处于 执行、就绪、阻塞 中的哪个状态

就绪态：cpu满足了处理机之外的所有资源条件，一旦cpu空闲，os就可能调度cpu去执行就绪态的进程

运行态：进程占用cpu



就绪 《》 运行：运行和就绪态之间，是可以互相切换
比如分时操作系统，如果当前进程的时间片执行完了，会被os调度进入就绪队列，等下一个时间片上处理机，再进入运行态

运行 》阻塞：运行态 可以进入 阻塞态
比如该进程所需要的某资源还没准备好，那么该进程进入阻塞态，等待资源

阻塞 》就绪：阻塞态 可以进入 就绪态
比如该进程所需要的资源准备好了，那么该进程进入就绪态，等待os调度



运行 》阻塞 》就绪 《》运行 



并发的进程 在运行过程中, 指令的运行是完全靠 os 调度的, 所以体现在 打印输出上, 顺序会变化（os调度不同）


处理机调度：
当一个进程 被判定 阻塞之后, os 会去寻找 进程池中处于 「就绪」 状态的的进程们, 并按自己的调度算法去执行它们（让它们处于运行状态）
调度的算法要公平、高效
1、高级调度（作业调度）：把辅存（外存之外）中的资源调入内存。次数少
2、中级调度（内存对换）：将暂时不运行的进程调到内存之外（外存）。当cpu空闲时，会把外存的进程调回内存。次数中等
3、低级调度（进程调度）：

方式：
剥夺式：进程2优先比进程1高，剥夺进程1占用处理机的权力，进城2上处理机
非剥夺式：进程2优先比进程1高，但因为进程1在处理机上，要等进程1处理完

算法：
先来先服务
短作业优先
优先级调度算法
高响应比优先调度算法：（运行时间+等待时间）/等待时间
时间片轮转: 必须是剥夺式的
多级反馈队列调度


进程同步：协调进程之间的制约关系
1、同步：直接制约关系，多个进程需要协调它们的工作次序而等待、传递信息
2、互斥：间接制约关系，当一个进程进入临界区而使用临界资源的时候，另一个进程必须等待。当占用临界资源的进程退出之后，另一个进程才能进入临界区使用

临界资源：一次仅允许一个进程使用的资源：打印机、共享缓冲区、共享变量、公用队列

临界区：每个进程访问临界资源的「程序段」。也就是说，每个进程都有自己的「临界区」，它们可能涉及到共同的临界资源. 由此可见, 进程之间的临界区访问是“互斥”的

临界区互斥的原则：
1、空闲让进: 如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入
2、忙则等待: 任何时候，处于临界区的进程数量不能多于一个。如果已经有进程处于临界区，那么其他试图进入临界区的进程必须等待
3、有限等待: 进入临界区的进程必须要在有限时间内退出
4、让权等待: 如果进程进入不了自己的临界区，那么它应该让出处理机资源，避免进程“忙等”

实现临界区互斥的基本方法：信号量


死锁:  
多个进程因竞争资源（处理机）形成的僵局，外力如果不介入就不能解开

产生原因：非剥夺资源(处理机)的竞争, 和进程的不恰当推进顺序    和饥饿的区别：缺乏资源（处理机）
预防：破坏互斥条件、破坏不剥夺条件、破坏请求和保持条件、破坏循环等待条件
避免：安全状态  银行家算法
检测：利用死锁定理
解除：资源剥夺、撤销进程、进程回退

